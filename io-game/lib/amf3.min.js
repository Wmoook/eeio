/* Minimal AMF3 decoder (U29 integers, doubles, strings, arrays, objects, bytearray) */
(function(global){
  'use strict';
  function Reader(bytes){
    this.b = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
    this.p = 0;
    this.strRefs = [];
    this.objRefs = [];
    this.traitRefs = [];
  }
  Reader.prototype.readU8 = function(){ return this.b[this.p++]; };
  Reader.prototype.readDbl = function(){
    const v = new DataView(this.b.buffer, this.b.byteOffset + this.p, 8).getFloat64(0,false);
    this.p += 8; return v;
  };
  Reader.prototype.readU29 = function(){
    // up to 29-bit varint (AMF3)
    let v = 0; let b = this.readU8();
    if (b < 128) return b;
    v = (b & 0x7f) << 7; b = this.readU8();
    if (b < 128) return v | b;
    v = (v | (b & 0x7f)) << 7; b = this.readU8();
    if (b < 128) return v | b;
    v = (v | (b & 0x7f)) << 8; b = this.readU8();
    return v | b;
  };
  Reader.prototype.readStringAMF3 = function(){
    const ref = this.readU29();
    const isRef = (ref & 1) === 0;
    const idx = ref >> 1;
    if (isRef) return this.strRefs[idx] || '';
    const len = idx;
    if (len === 0) { this.strRefs.push(''); return ''; }
    const start = this.p; const end = start + len;
    const slice = this.b.subarray(start, end); this.p = end;
    const s = new TextDecoder('utf-8').decode(slice);
    this.strRefs.push(s);
    return s;
  };
  Reader.prototype.readTraits = function(){
    const u = this.readU29();
    if ((u & 3) === 1) return this.traitRefs[u >> 2];
    const ext = (u & 8) !== 0;
    const dyn = (u & 4) !== 0;
    const count = (u >> 4);
    const className = this.readStringAMF3();
    const props = [];
    for (let i=0;i<count;i++) props.push(this.readStringAMF3());
    const traits = { className, props, dynamic: dyn, externalizable: ext };
    this.traitRefs.push(traits);
    return traits;
  };
  Reader.prototype.readObject = function(){
    const u = this.readU29();
    if ((u & 1) === 0) { const idx = u >> 1; return this.objRefs[idx]; }
    const traitInfo = ((u & 2) === 0) ? this.readTraits() : null;
    let obj;
    if (traitInfo && traitInfo.externalizable) {
      // Unsupported; read as raw ByteArray payload
      const len = this.readU29() >>> 1;
      const start = this.p; this.p += len;
      obj = { __external__: true, className: traitInfo.className, payload: this.b.subarray(start, start+len) };
    } else {
      const traits = traitInfo || this.readTraits();
      obj = {};
      this.objRefs.push(obj);
      // sealed
      for (let i=0;i<traits.props.length;i++) {
        const key = traits.props[i];
        obj[key] = this.readValue();
      }
      // dynamic
      if (traits.dynamic) {
        while (true) {
          const name = this.readStringAMF3();
          if (!name || name.length === 0) break;
          obj[name] = this.readValue();
        }
      }
    }
    return obj;
  };
  Reader.prototype.readArray = function(){
    const u = this.readU29();
    if ((u & 1) === 0) return this.objRefs[u >> 1];
    const denseLen = (u >> 1);
    const assoc = {};
    while (true) {
      const key = this.readStringAMF3();
      if (!key || key.length === 0) break;
      assoc[key] = this.readValue();
    }
    const arr = [];
    this.objRefs.push(arr);
    for (let i=0;i<denseLen;i++) arr.push(this.readValue());
    // attach associative fields if any
    for (const k in assoc) { arr[k] = assoc[k]; }
    return arr;
  };
  Reader.prototype.readByteArray = function(){
    const u = this.readU29();
    if ((u & 1) === 0) return this.objRefs[u >> 1];
    const len = u >> 1;
    const start = this.p; const end = start + len; this.p = end;
    const bytes = this.b.slice(start, end);
    this.objRefs.push(bytes);
    return bytes;
  };
  Reader.prototype.readValue = function(){
    const marker = this.readU8();
    switch (marker) {
      case 0x00: return undefined; // undefined
      case 0x01: return null; // null
      case 0x02: return false;
      case 0x03: return true;
      case 0x04: { // integer U29 with sign correction
        let v = this.readU29();
        if (v & 0x10000000) v = v - 0x20000000; // sign extend 29-bit
        return v;
      }
      case 0x05: return this.readDbl();
      case 0x06: return this.readStringAMF3();
      case 0x09: return this.readArray();
      case 0x0A: return this.readObject();
      case 0x0C: return this.readByteArray();
      default:
        // Skip unsupported types gracefully
        return null;
    }
  };
  function decode(bytes){
    try { const r = new Reader(bytes); return r.readValue(); } catch(e){ return null; }
  }
  global.AMF3 = { Reader: Reader, decode: decode };
})(typeof window !== 'undefined' ? window : globalThis);


